package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"github.com/snowmerak/gofn/parser"
)

// GenerateFor writes generated files to outDir for given structs and funcs
func GenerateFor(outDir string, structs []parser.StructInfo, funcs []parser.FuncInfo) error {
	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return err
	}

	// generate one file per struct with directive
	for _, s := range structs {
		if s.Directive == "" {
			continue
		}
		var buf bytes.Buffer
		hdr := fmt.Sprintf("// Code generated by gofn; DO NOT EDIT.\n// gofn: %s\n\n", s.Directive)
		buf.WriteString(hdr)
		buf.WriteString("package " + s.Package + "\n\n")

		dir := normalizeDirective(s.Directive)
		if dir == "record" {
			// enforce private struct and private fields only
			if !isPrivateIdent(s.Name) {
				// skip generation if type is not private
				continue
			}
			allFieldsPrivate := true
			for _, f := range s.Fields {
				if f.Name == "" || !isPrivateIdent(f.Name) {
					allFieldsPrivate = false
					break
				}
			}
			if !allFieldsPrivate {
				// skip generation if any field is not private or unnamed
				continue
			}
			// build exported interface name
			ifaceName := exportName(s.Name)

			// constructor params and assignments
			params := []string{}
			assigns := []string{}
			for i, f := range s.Fields {
				pname := fieldParamName(f.Name, i)
				params = append(params, fmt.Sprintf("%s %s", pname, f.Type))
				assigns = append(assigns, fmt.Sprintf("%s: %s", f.Name, pname))
			}
			ctorName := "New" + ifaceName

			// generate exported interface type
			buf.WriteString(fmt.Sprintf("type %s interface {\n", ifaceName))
			for _, f := range s.Fields {
				buf.WriteString(fmt.Sprintf("    %s() %s\n", exportName(f.Name), f.Type))
			}
			buf.WriteString("}\n\n")

			// constructor returns the exported interface, implemented by private type
			ctor := fmt.Sprintf("// Generated record constructor for %s\nfunc %s(%s) %s {\n    return %s{%s}\n}\n\n",
				s.Name,
				ctorName,
				strings.Join(params, ", "),
				ifaceName,
				s.Name,
				strings.Join(assigns, ", "),
			)
			buf.WriteString(ctor)

			// getters (methods on private type) to satisfy interface
			recv := strings.ToLower(string(s.Name[0]))
			for _, f := range s.Fields {
				gname := exportName(f.Name)
				// method signature uses value receiver
				getter := fmt.Sprintf("func (%s %s) %s() %s {\n    return %s.%s\n}\n\n",
					recv,
					s.Name,
					gname,
					f.Type,
					recv,
					f.Name,
				)
				buf.WriteString(getter)
			}
		} else {
			// fallback: create an immutable constructor
			ctor := fmt.Sprintf("// Generated constructor for %s\nfunc New%s(%s) %s {\n    return %s{%s}\n}\n\n",
				s.Name,
				s.Name,
				paramsForFields(s.Fields),
				s.Name,
				s.Name,
				valuesForFields(s.Fields),
			)
			buf.WriteString(ctor)
		}

		fname := fmt.Sprintf("%s_%s_gen.go", s.Name, normalizeDirective(s.Directive))
		out := filepath.Join(outDir, fname)
		formatted, err := formatSource(buf.Bytes())
		if err != nil {
			return err
		}
		if err := os.WriteFile(out, formatted, 0o644); err != nil {
			return err
		}
	}

	// generate one file per func with directive
	for _, f := range funcs {
		if f.Directive == "" {
			continue
		}
		if len(f.Results) > 1 {
			// skip funcs with multiple results for now
			continue
		}
		var buf bytes.Buffer
		hdr := fmt.Sprintf("// Code generated by gofn; DO NOT EDIT.\n// gofn: %s\n\n", f.Directive)
		buf.WriteString(hdr)
		buf.WriteString("package " + f.Package + "\n\n")
		wrapper := generateCurriedFunc(f)
		buf.WriteString(wrapper + "\n")

		fname := fmt.Sprintf("%s_%s_gen.go", f.Name, normalizeDirective(f.Directive))
		out := filepath.Join(outDir, fname)
		formatted, err := formatSource(buf.Bytes())
		if err != nil {
			return err
		}
		if err := os.WriteFile(out, formatted, 0o644); err != nil {
			return err
		}
	}

	return nil
}

func paramsForFields(fields []parser.FieldInfo) string {
	parts := []string{}
	for _, f := range fields {
		name := f.Name
		if name == "" {
			name = "_f"
		}
		parts = append(parts, fmt.Sprintf("%s %s", strings.ToLower(name), f.Type))
	}
	return strings.Join(parts, ", ")
}

func valuesForFields(fields []parser.FieldInfo) string {
	parts := []string{}
	for _, f := range fields {
		name := f.Name
		if name == "" {
			name = "_f"
		}
		parts = append(parts, strings.ToLower(name)+": "+strings.ToLower(name))
	}
	return strings.Join(parts, ", ")
}

func generateCurriedFunc(f parser.FuncInfo) string {
	var b strings.Builder
	n := len(f.Params)
	resCount := len(f.Results)

	// helper to build remaining nested type starting at index i
	remainingType := func(i int) string {
		var sb strings.Builder
		for j := i; j < n; j++ {
			sb.WriteString("func(")
			sb.WriteString(paramName(f.Params[j], j))
			sb.WriteString(" ")
			sb.WriteString(f.Params[j].Type)
			sb.WriteString(") ")
		}
		if resCount == 1 {
			sb.WriteString(f.Results[0].Type)
		}
		return sb.String()
	}

	b.WriteString("// Generated curried wrapper for " + f.Name + "\n")

	// Top-level signature
	if n == 0 {
		// no params: just return original result directly
		if resCount == 0 {
			b.WriteString("func " + f.Name + "Curried() {")
		} else {
			b.WriteString("func " + f.Name + "Curried() " + f.Results[0].Type + " {")
		}
		b.WriteString("\n    ")
		if resCount == 0 {
			b.WriteString(f.Name + "()\n")
		} else {
			b.WriteString("return " + f.Name + "()\n")
		}
		b.WriteString("}\n")
		return b.String()
	}

	// signature: func NameCurried() <nested type>
	b.WriteString("func " + f.Name + "Curried() " + remainingType(0) + " {\n")

	// body: produce nested "return func(...) <remaining> {" lines
	for i := 0; i < n; i++ {
		indent := strings.Repeat("    ", i+1)
		b.WriteString(indent + "return func(")
		b.WriteString(paramName(f.Params[i], i) + " " + f.Params[i].Type + ") ")
		// remaining return type after this param
		rem := remainingType(i + 1)
		if rem != "" {
			b.WriteString(rem)
		}
		b.WriteString(" {\n")
	}

	// innermost: call original function
	innIndent := strings.Repeat("    ", n+1)
	if resCount == 0 {
		b.WriteString(innIndent + f.Name + "(")
	} else {
		b.WriteString(innIndent + "return " + f.Name + "(")
	}
	// arguments are parameter names p0..pn-1
	args := []string{}
	for i := 0; i < n; i++ {
		args = append(args, paramName(f.Params[i], i))
	}
	b.WriteString(strings.Join(args, ", ") + ")\n")

	// close braces
	for i := n - 1; i >= 0; i-- {
		indent := strings.Repeat("    ", i+1)
		b.WriteString(indent + "}\n")
	}

	// close outer function
	b.WriteString("}\n")

	return b.String()
}

func paramName(p parser.ParamInfo, i int) string {
	if p.Name != "" {
		return p.Name
	}
	return fmt.Sprintf("p%d", i)
}

func formatSource(src []byte) ([]byte, error) {
	out, err := format.Source(src)
	if err != nil {
		// return original with error so caller can decide
		return src, fmt.Errorf("gofn: format error: %w", err)
	}
	return out, nil
}

func normalizeDirective(d string) string {
	// keep alnum and replace others with underscore, and lowercase
	var b strings.Builder
	for _, r := range strings.ToLower(strings.TrimSpace(d)) {
		if (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') {
			b.WriteRune(r)
		} else {
			b.WriteRune('_')
		}
	}
	return b.String()
}

func exportName(s string) string {
	if s == "" {
		return s
	}
	rs := []rune(s)
	rs[0] = unicode.ToUpper(rs[0])
	return string(rs)
}

func fieldParamName(field string, i int) string {
	if field != "" {
		// if field already starts with lowercase, use as-is; otherwise lowercase first rune
		rs := []rune(field)
		rs[0] = unicode.ToLower(rs[0])
		return string(rs)
	}
	return fmt.Sprintf("f%d", i)
}

func isPrivateIdent(s string) bool {
	if s == "" {
		return false
	}
	r := []rune(s)[0]
	return unicode.IsLower(r)
}
