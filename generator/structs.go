package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/snowmerak/gofn/parser"
)

func generateStructs(outDir string, structs []parser.StructInfo) error {
	for _, s := range structs {
		if s.Directive == "" {
			continue
		}
		var buf bytes.Buffer
		hdr := fmt.Sprintf("// Code generated by gofn; DO NOT EDIT.\n// gofn: %s\n\n", s.Directive)
		buf.WriteString(hdr)
		buf.WriteString("package " + s.Package + "\n\n")

		dir := normalizeDirective(s.Directive)
		if dir == "record" {
			// enforce private struct and private fields only
			if !isPrivateIdent(s.Name) {
				// skip generation if type is not private
				continue
			}
			allFieldsPrivate := true
			for _, f := range s.Fields {
				if f.Name == "" || !isPrivateIdent(f.Name) {
					allFieldsPrivate = false
					break
				}
			}
			if !allFieldsPrivate {
				// skip generation if any field is not private or unnamed
				continue
			}

			// build exported interface name
			ifaceName := exportName(s.Name)

			// constructor params and assignments (required fields)
			params := []string{}
			assigns := []string{}
			for i, f := range s.Fields {
				pname := fieldParamName(f.Name, i)
				params = append(params, fmt.Sprintf("%s %s", pname, f.Type))
				assigns = append(assigns, fmt.Sprintf("%s: %s", f.Name, pname))
			}
			ctorName := "New" + ifaceName

			// generate exported interface type
			buf.WriteString(fmt.Sprintf("type %s interface {\n", ifaceName))
			for _, f := range s.Fields {
				buf.WriteString(fmt.Sprintf("    %s() %s\n", exportName(f.Name), f.Type))
			}
			buf.WriteString("}\n\n")

			// constructor returns the exported interface, implemented by private type
			// provide two forms: basic constructor and options-based constructor
			baseCtor := fmt.Sprintf("// Generated record constructor for %s\nfunc %s(%s) %s {\n    return %s{%s}\n}\n\n",
				s.Name,
				ctorName,
				strings.Join(params, ", "),
				ifaceName,
				s.Name,
				strings.Join(assigns, ", "),
			)
			buf.WriteString(baseCtor)

			// getters (methods on private type) to satisfy interface
			recv := strings.ToLower(string(s.Name[0]))
			for _, f := range s.Fields {
				gname := exportName(f.Name)
				// method signature uses value receiver
				getter := fmt.Sprintf("func (%s %s) %s() %s {\n    return %s.%s\n}\n\n",
					recv,
					s.Name,
					gname,
					f.Type,
					recv,
					f.Name,
				)
				buf.WriteString(getter)
			}
		} else if dir == "optional" {
			// generate only functional options and an options-based constructor
			optTypeName := exportName(s.Name) + "Option"
			buf.WriteString(fmt.Sprintf("type %s func(*%s)\n\n", optTypeName, s.Name))
			for i, f := range s.Fields {
				pname := fieldParamName(f.Name, i)
				buf.WriteString(fmt.Sprintf("func With%s(%s %s) %s {\n    return func(r *%s) { r.%s = %s }\n}\n\n",
					exportName(f.Name),
					pname,
					f.Type,
					optTypeName,
					s.Name,
					f.Name,
					pname,
				))
			}

			// options-based constructor returns the concrete type
			buf.WriteString(fmt.Sprintf("func New%sWithOptions(opts ...%s) %s {\n    r := %s{}\n    for _, o := range opts { o(&r) }\n    return r\n}\n\n",
				exportName(s.Name),
				optTypeName,
				s.Name,
				s.Name,
			))
		} else {
			// fallback: create an immutable constructor
			ctor := fmt.Sprintf("// Generated constructor for %s\nfunc New%s(%s) %s {\n    return %s{%s}\n}\n\n",
				s.Name,
				s.Name,
				paramsForFields(s.Fields),
				s.Name,
				s.Name,
				valuesForFields(s.Fields),
			)
			buf.WriteString(ctor)
		}

		fname := fmt.Sprintf("%s_%s_gen.go", s.Name, normalizeDirective(s.Directive))
		out := filepath.Join(outDir, fname)
		formatted, err := formatSource(buf.Bytes())
		if err != nil {
			return err
		}
		if err := os.WriteFile(out, formatted, 0o644); err != nil {
			return err
		}
	}
	return nil
}
