package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/snowmerak/gofn/parser"
)

// generateStructs generates code for structs based on directives
func generateStructs(outDir string, structs []parser.StructInfo) error {
	for _, s := range structs {
		dir := strings.TrimSpace(s.Directive)
		if dir == "" {
			continue
		}

		var buf bytes.Buffer
		hdr := fmt.Sprintf("// Code generated by gofn; DO NOT EDIT.\n// gofn: %s\n\n", dir)
		buf.WriteString(hdr)
		buf.WriteString("package " + s.Package + "\n\n")

		// generation per-directive
		switch dir {
		case "pipeline":
			// generate composer using monad.Result
			buf.WriteString("import (\n\t\"github.com/snowmerak/gofn/monad\"\n)\n\n")
			compName := exportName(s.Name) + "Composer"
			n := len(s.Fields)
			if n < 2 {
				buf.WriteString("// pipeline: not enough fields to compose\n")
			} else {
				// build parameters: f1 func(T1) monad.Result[T2], ..., f{n-1}
				parts := []string{}
				for i := 0; i < n-1; i++ {
					parts = append(parts, fmt.Sprintf("f%d func(%s) monad.Result[%s]", i+1, s.Fields[i].Type, s.Fields[i+1].Type))
				}
				buf.WriteString(fmt.Sprintf("func %s(%s) func(%s) monad.Result[%s] {\n", compName, strings.Join(parts, ", "), s.Fields[0].Type, s.Fields[n-1].Type))

				// body (generated composer)
				buf.WriteString("    return func(t1 " + s.Fields[0].Type + ") monad.Result[" + s.Fields[n-1].Type + "] {\n")
				if n == 2 {
					// single-stage: just forward the call
					buf.WriteString("        return f1(t1)\n")
				} else {
					// first stage: unwrap to get value for next
					buf.WriteString("        v1, err := f1(t1).Unwrap()\n")
					buf.WriteString("        if err != nil { return monad.Err[" + s.Fields[n-1].Type + "](err) }\n")
					// middle stages: unwrap up to n-2
					for i := 2; i <= n-2; i++ {
						prev := fmt.Sprintf("v%d", i-1)
						buf.WriteString(fmt.Sprintf("        v%d, err := f%d(%s).Unwrap()\n", i, i, prev))
						buf.WriteString(fmt.Sprintf("        if err != nil { return monad.Err[%s](err) }\n", s.Fields[n-1].Type))
					}
					// final stage: call last function and return its Result
					buf.WriteString(fmt.Sprintf("        return f%d(v%d)\n", n-1, n-2))
				}
				buf.WriteString("    }\n")
				// close outer function
				buf.WriteString("}\n\n")
			}

		case "record":
			// enforce private struct name and private fields
			if !isPrivateIdent(s.Name) {
				continue
			}
			allFieldsPrivate := true
			for _, f := range s.Fields {
				if f.Name == "" || !isPrivateIdent(f.Name) {
					allFieldsPrivate = false
					break
				}
			}
			if !allFieldsPrivate {
				continue
			}

			ifaceName := exportName(s.Name)
			// interface
			buf.WriteString(fmt.Sprintf("type %s interface {\n", ifaceName))
			for _, f := range s.Fields {
				buf.WriteString(fmt.Sprintf("    %s() %s\n", exportName(f.Name), f.Type))
			}
			buf.WriteString("}\n\n")

			// constructor
			params := []string{}
			assigns := []string{}
			for i, f := range s.Fields {
				pname := fieldParamName(f.Name, i)
				params = append(params, fmt.Sprintf("%s %s", pname, f.Type))
				assigns = append(assigns, fmt.Sprintf("%s: %s", f.Name, pname))
			}
			ctorName := "New" + ifaceName
			baseCtor := fmt.Sprintf("// Generated record constructor for %s\nfunc %s(%s) %s {\n    return %s{%s}\n}\n\n",
				s.Name, ctorName, strings.Join(params, ", "), ifaceName, s.Name, strings.Join(assigns, ", "))
			buf.WriteString(baseCtor)

			// getters
			recv := strings.ToLower(string(s.Name[0]))
			for _, f := range s.Fields {
				gname := exportName(f.Name)
				getter := fmt.Sprintf("func (%s %s) %s() %s {\n    return %s.%s\n}\n\n", recv, s.Name, gname, f.Type, recv, f.Name)
				buf.WriteString(getter)
			}

		case "optional":
			optTypeName := exportName(s.Name) + "Option"
			buf.WriteString(fmt.Sprintf("type %s func(*%s)\n\n", optTypeName, s.Name))
			for i, f := range s.Fields {
				pname := fieldParamName(f.Name, i)
				buf.WriteString(fmt.Sprintf("func With%s(%s %s) %s {\n    return func(r *%s) { r.%s = %s }\n}\n\n",
					exportName(f.Name), pname, f.Type, optTypeName, s.Name, f.Name, pname))
			}
			buf.WriteString(fmt.Sprintf("func New%sWithOptions(opts ...%s) %s {\n    r := %s{}\n    for _, o := range opts { o(&r) }\n    return r\n}\n\n",
				exportName(s.Name), optTypeName, s.Name, s.Name))

		default:
			// fallback constructor
			ctor := fmt.Sprintf("// Generated constructor for %s\nfunc New%s(%s) %s {\n    return %s{%s}\n}\n\n",
				s.Name, s.Name, paramsForFields(s.Fields), s.Name, s.Name, valuesForFields(s.Fields))
			buf.WriteString(ctor)
		}

		fname := fmt.Sprintf("%s_%s_gen.go", s.Name, normalizeDirective(s.Directive))
		out := filepath.Join(outDir, fname)

		// try to find source path
		srcPath := ""
		if s.Pos.Filename != "" {
			srcPath = s.Pos.Filename
		}

		formatted, err := formatSource(buf.Bytes())
		if err != nil {
			// dump raw source for inspection
			_ = os.WriteFile(out+".bad.go", buf.Bytes(), 0o644)
			fmt.Printf("gofn: format failed for %s: %v\n", fname, err)
			fmt.Printf("gofn: dumped raw source to %s.bad.go\n", out)
			return err
		}

		doGen, reason, serr := shouldGenerate(srcPath, out)
		if serr != nil {
			fmt.Printf("gofn: check should-generate for %s: %v\n", fname, serr)
		}
		if !doGen {
			fmt.Printf("gofn: skip %s - %s\n", fname, reason)
			continue
		}

		if err := os.WriteFile(out, formatted, 0o644); err != nil {
			fmt.Printf("gofn: failed to write %s: %v\n", out, err)
			return err
		}
		fmt.Printf("gofn: generated %s\n", out)
	}
	return nil
}
