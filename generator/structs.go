package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/snowmerak/gofn/parser"
)

// generateStructs generates code for structs based on directives
func generateStructs(outDir string, structs []parser.StructInfo) error {
	for _, s := range structs {
		dir := strings.TrimSpace(s.Directive)
		if dir == "" {
			continue
		}

		var buf bytes.Buffer
		hdr := fmt.Sprintf("// Code generated by gofn; DO NOT EDIT.\n// gofn: %s\n\n", dir)
		buf.WriteString(hdr)
		buf.WriteString("package " + s.Package + "\n\n")

		// generation per-directive
		switch dir {
		case "pipeline":
			// generate composer using monad.Result
			buf.WriteString("import (\n\t\"github.com/snowmerak/gofn/monad\"\n)\n\n")
			compName := exportName(s.Name) + "Composer"
			compWithErrorName := exportName(s.Name) + "ComposerWithErrorHandler"
			n := len(s.Fields)
			if n < 2 {
				buf.WriteString("// pipeline: not enough fields to compose\n")
			} else {
				// 1. Basic composer (existing functionality)
				parts := []string{}
				for i := 0; i < n-1; i++ {
					parts = append(parts, fmt.Sprintf("f%d func(%s) monad.Result[%s]", i+1, s.Fields[i].Type, s.Fields[i+1].Type))
				}
				buf.WriteString(fmt.Sprintf("func %s(%s) func(%s) monad.Result[%s] {\n", compName, strings.Join(parts, ", "), s.Fields[0].Type, s.Fields[n-1].Type))

				// Basic composer body
				buf.WriteString("    return func(t1 " + s.Fields[0].Type + ") monad.Result[" + s.Fields[n-1].Type + "] {\n")
				if n == 2 {
					buf.WriteString("        return f1(t1)\n")
				} else {
					buf.WriteString("        v1, err := f1(t1).Unwrap()\n")
					buf.WriteString("        if err != nil { return monad.Err[" + s.Fields[n-1].Type + "](err) }\n")
					for i := 2; i <= n-2; i++ {
						prev := fmt.Sprintf("v%d", i-1)
						buf.WriteString(fmt.Sprintf("        v%d, err := f%d(%s).Unwrap()\n", i, i, prev))
						buf.WriteString(fmt.Sprintf("        if err != nil { return monad.Err[%s](err) }\n", s.Fields[n-1].Type))
					}
					buf.WriteString(fmt.Sprintf("        return f%d(v%d)\n", n-1, n-2))
				}
				buf.WriteString("    }\n")
				buf.WriteString("}\n\n")

				// 2. Composer with error handler
				partsWithHandler := make([]string, len(parts))
				copy(partsWithHandler, parts)
				partsWithHandler = append(partsWithHandler, fmt.Sprintf("errorHandler func(int, error) monad.Result[%s]", s.Fields[n-1].Type))

				buf.WriteString(fmt.Sprintf("// %s creates a pipeline composer with error handling capability\n", compWithErrorName))
				buf.WriteString("// errorHandler receives (stageIndex, error) and can return a recovery value or propagate the error\n")
				buf.WriteString(fmt.Sprintf("func %s(%s) func(%s) monad.Result[%s] {\n", compWithErrorName, strings.Join(partsWithHandler, ", "), s.Fields[0].Type, s.Fields[n-1].Type))

				// Error handling composer body
				buf.WriteString("    return func(t1 " + s.Fields[0].Type + ") monad.Result[" + s.Fields[n-1].Type + "] {\n")
				if n == 2 {
					buf.WriteString("        result := f1(t1)\n")
					buf.WriteString("        if !result.IsOk() {\n")
					buf.WriteString("            _, err := result.Unwrap()\n")
					buf.WriteString("            return errorHandler(1, err)\n")
					buf.WriteString("        }\n")
					buf.WriteString("        return result\n")
				} else {
					buf.WriteString("        v1, err := f1(t1).Unwrap()\n")
					buf.WriteString("        if err != nil {\n")
					buf.WriteString("            return errorHandler(1, err)\n")
					buf.WriteString("        }\n")

					for i := 2; i <= n-2; i++ {
						prev := fmt.Sprintf("v%d", i-1)
						buf.WriteString(fmt.Sprintf("        v%d, err := f%d(%s).Unwrap()\n", i, i, prev))
						buf.WriteString("        if err != nil {\n")
						buf.WriteString(fmt.Sprintf("            return errorHandler(%d, err)\n", i))
						buf.WriteString("        }\n")
					}

					buf.WriteString(fmt.Sprintf("        result := f%d(v%d)\n", n-1, n-2))
					buf.WriteString("        if !result.IsOk() {\n")
					buf.WriteString("            _, err := result.Unwrap()\n")
					buf.WriteString(fmt.Sprintf("            return errorHandler(%d, err)\n", n-1))
					buf.WriteString("        }\n")
					buf.WriteString("        return result\n")
				}
				buf.WriteString("    }\n")
				buf.WriteString("}\n\n")

				// 3. Helper functions for common error handling patterns
				buf.WriteString(fmt.Sprintf("// %sWithFallback creates an error handler that provides fallback values\n", exportName(s.Name)))
				buf.WriteString(fmt.Sprintf("func %sWithFallback(fallbackValue %s) func(int, error) monad.Result[%s] {\n", exportName(s.Name), s.Fields[n-1].Type, s.Fields[n-1].Type))
				buf.WriteString(fmt.Sprintf("    return func(stageIndex int, err error) monad.Result[%s] {\n", s.Fields[n-1].Type))
				buf.WriteString("        return monad.Ok(fallbackValue)\n")
				buf.WriteString("    }\n")
				buf.WriteString("}\n\n")

				buf.WriteString(fmt.Sprintf("// %sWithLogging creates an error handler that logs errors and propagates them\n", exportName(s.Name)))
				buf.WriteString(fmt.Sprintf("func %sWithLogging(logger func(int, error)) func(int, error) monad.Result[%s] {\n", exportName(s.Name), s.Fields[n-1].Type))
				buf.WriteString(fmt.Sprintf("    return func(stageIndex int, err error) monad.Result[%s] {\n", s.Fields[n-1].Type))
				buf.WriteString("        logger(stageIndex, err)\n")
				buf.WriteString(fmt.Sprintf("        return monad.Err[%s](err)\n", s.Fields[n-1].Type))
				buf.WriteString("    }\n")
				buf.WriteString("}\n\n")
			}

		case "record":
			// enforce private struct name and private fields
			if !isPrivateIdent(s.Name) {
				continue
			}
			allFieldsPrivate := true
			for _, f := range s.Fields {
				if f.Name == "" || !isPrivateIdent(f.Name) {
					allFieldsPrivate = false
					break
				}
			}
			if !allFieldsPrivate {
				continue
			}

			ifaceName := exportName(s.Name)
			// interface
			buf.WriteString(fmt.Sprintf("type %s interface {\n", ifaceName))
			for _, f := range s.Fields {
				buf.WriteString(fmt.Sprintf("    %s() %s\n", exportName(f.Name), f.Type))
			}
			buf.WriteString("}\n\n")

			// constructor
			params := []string{}
			assigns := []string{}
			for i, f := range s.Fields {
				pname := fieldParamName(f.Name, i)
				params = append(params, fmt.Sprintf("%s %s", pname, f.Type))
				assigns = append(assigns, fmt.Sprintf("%s: %s", f.Name, pname))
			}
			ctorName := "New" + ifaceName
			baseCtor := fmt.Sprintf("// Generated record constructor for %s\nfunc %s(%s) %s {\n    return %s{%s}\n}\n\n",
				s.Name, ctorName, strings.Join(params, ", "), ifaceName, s.Name, strings.Join(assigns, ", "))
			buf.WriteString(baseCtor)

			// getters
			recv := strings.ToLower(string(s.Name[0]))
			for _, f := range s.Fields {
				gname := exportName(f.Name)
				getter := fmt.Sprintf("func (%s %s) %s() %s {\n    return %s.%s\n}\n\n", recv, s.Name, gname, f.Type, recv, f.Name)
				buf.WriteString(getter)
			}

		case "optional":
			optTypeName := exportName(s.Name) + "Option"
			buf.WriteString(fmt.Sprintf("type %s func(*%s)\n\n", optTypeName, s.Name))
			for i, f := range s.Fields {
				pname := fieldParamName(f.Name, i)
				buf.WriteString(fmt.Sprintf("func With%s(%s %s) %s {\n    return func(r *%s) { r.%s = %s }\n}\n\n",
					exportName(f.Name), pname, f.Type, optTypeName, s.Name, f.Name, pname))
			}
			buf.WriteString(fmt.Sprintf("func New%sWithOptions(opts ...%s) %s {\n    r := %s{}\n    for _, o := range opts { o(&r) }\n    return r\n}\n\n",
				exportName(s.Name), optTypeName, s.Name, s.Name))

		case "match":
			// Generate pattern matching code
			if err := generateMatchCode(&buf, s); err != nil {
				return fmt.Errorf("generating match code for %s: %w", s.Name, err)
			}

		case "reactive":
			// Generate reactive wrapper code
			if err := generateReactiveCode(&buf, s); err != nil {
				return fmt.Errorf("generating reactive code for %s: %w", s.Name, err)
			}

		case "ref":
			// Generate reference wrapper code
			if err := generateRefCode(&buf, s); err != nil {
				return fmt.Errorf("generating ref code for %s: %w", s.Name, err)
			}

		default:
			// fallback constructor
			ctor := fmt.Sprintf("// Generated constructor for %s\nfunc New%s(%s) %s {\n    return %s{%s}\n}\n\n",
				s.Name, s.Name, paramsForFields(s.Fields), s.Name, s.Name, valuesForFields(s.Fields))
			buf.WriteString(ctor)
		}

		fname := fmt.Sprintf("%s_%s_gen.go", s.Name, normalizeDirective(s.Directive))
		out := filepath.Join(outDir, fname)

		// try to find source path
		srcPath := ""
		if s.Pos.Filename != "" {
			srcPath = s.Pos.Filename
		}

		formatted, err := formatSource(buf.Bytes())
		if err != nil {
			// dump raw source for inspection
			_ = os.WriteFile(out+".bad.go", buf.Bytes(), 0o644)
			fmt.Printf("gofn: format failed for %s: %v\n", fname, err)
			fmt.Printf("gofn: dumped raw source to %s.bad.go\n", out)
			return err
		}

		doGen, reason, serr := shouldGenerate(srcPath, out)
		if serr != nil {
			fmt.Printf("gofn: check should-generate for %s: %v\n", fname, serr)
		}
		if !doGen {
			fmt.Printf("gofn: skip %s - %s\n", fname, reason)
			continue
		}

		if err := os.WriteFile(out, formatted, 0o644); err != nil {
			fmt.Printf("gofn: failed to write %s: %v\n", out, err)
			return err
		}
		fmt.Printf("gofn: generated %s\n", out)
	}
	return nil
}

// generateMatchCode generates pattern matching code for a struct
func generateMatchCode(buf *bytes.Buffer, s parser.StructInfo) error {
	structName := s.Name
	matcherName := exportName(structName) + "Matcher"
	returnMatcherName := exportName(structName) + "MatcherWithReturn"

	// Add import for monad package
	buf.WriteString("import \"github.com/snowmerak/gofn/monad\"\n\n")

	// Generate matcher structs
	buf.WriteString(fmt.Sprintf("// %s provides pattern matching for %s\n", matcherName, structName))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", matcherName))
	buf.WriteString(fmt.Sprintf("\tvalue   %s\n", structName))
	buf.WriteString("\tmatched bool\n")
	buf.WriteString("}\n\n")

	buf.WriteString(fmt.Sprintf("// %s provides pattern matching with return values\n", returnMatcherName))
	buf.WriteString(fmt.Sprintf("type %s[T any] struct {\n", returnMatcherName))
	buf.WriteString(fmt.Sprintf("\tvalue   %s\n", structName))
	buf.WriteString("\tmatched bool\n")
	buf.WriteString("\tresult  T\n")
	buf.WriteString("}\n\n")

	// Generate Match method
	buf.WriteString(fmt.Sprintf("// Match starts pattern matching on %s\n", structName))
	buf.WriteString(fmt.Sprintf("func (%s %s) Match() *%s {\n",
		strings.ToLower(string(structName[0])), structName, matcherName))
	buf.WriteString(fmt.Sprintf("\treturn &%s{value: %s, matched: false}\n",
		matcherName, strings.ToLower(string(structName[0]))))
	buf.WriteString("}\n\n")

	// Generate MatchReturn function (since Go doesn't support generic methods)
	buf.WriteString(fmt.Sprintf("// Match%sReturn starts pattern matching with return value on %s\n",
		exportName(structName), structName))
	buf.WriteString(fmt.Sprintf("func Match%sReturn[T any](%s %s) *%s[T] {\n",
		exportName(structName), strings.ToLower(string(structName[0])), structName, returnMatcherName))
	buf.WriteString("\tvar zero T\n")
	buf.WriteString(fmt.Sprintf("\treturn &%s[T]{value: %s, matched: false, result: zero}\n",
		returnMatcherName, strings.ToLower(string(structName[0]))))
	buf.WriteString("}\n\n")

	// Generate When method for basic matcher
	buf.WriteString("// When matches against the provided pattern\n")
	buf.WriteString(fmt.Sprintf("func (m *%s) When(\n", matcherName))

	// Generate parameters for each field
	for _, field := range s.Fields {
		buf.WriteString(fmt.Sprintf("\t%s monad.Option[%s],\n",
			strings.ToLower(field.Name), field.Type))
	}
	buf.WriteString(fmt.Sprintf("\thandler func(%s),\n", structName))
	buf.WriteString(fmt.Sprintf(") *%s {\n", matcherName))

	buf.WriteString("\tif m.matched {\n\t\treturn m\n\t}\n\t\n")
	buf.WriteString("\tif m.matchFields(")

	// Add field parameters to matchFields call
	fieldParams := make([]string, len(s.Fields))
	for i, field := range s.Fields {
		fieldParams[i] = strings.ToLower(field.Name)
	}
	buf.WriteString(strings.Join(fieldParams, ", "))
	buf.WriteString(") {\n")
	buf.WriteString("\t\thandler(m.value)\n")
	buf.WriteString("\t\tm.matched = true\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn m\n")
	buf.WriteString("}\n\n")

	// Generate WhenGuard method
	buf.WriteString("// WhenGuard matches against pattern with additional condition\n")
	buf.WriteString(fmt.Sprintf("func (m *%s) WhenGuard(\n", matcherName))

	for _, field := range s.Fields {
		buf.WriteString(fmt.Sprintf("\t%s monad.Option[%s],\n",
			strings.ToLower(field.Name), field.Type))
	}
	buf.WriteString(fmt.Sprintf("\tguard func(%s) bool,\n", structName))
	buf.WriteString(fmt.Sprintf("\thandler func(%s),\n", structName))
	buf.WriteString(fmt.Sprintf(") *%s {\n", matcherName))

	buf.WriteString("\tif m.matched {\n\t\treturn m\n\t}\n\t\n")
	buf.WriteString("\tif m.matchFields(")
	buf.WriteString(strings.Join(fieldParams, ", "))
	buf.WriteString(") && guard(m.value) {\n")
	buf.WriteString("\t\thandler(m.value)\n")
	buf.WriteString("\t\tm.matched = true\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn m\n")
	buf.WriteString("}\n\n")

	// Generate Default method
	buf.WriteString("// Default executes if no pattern matched\n")
	buf.WriteString(fmt.Sprintf("func (m *%s) Default(handler func(%s)) {\n", matcherName, structName))
	buf.WriteString("\tif !m.matched {\n")
	buf.WriteString("\t\thandler(m.value)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	// Generate When method for return matcher
	buf.WriteString("// When matches against pattern and returns a value\n")
	buf.WriteString(fmt.Sprintf("func (m *%s[T]) When(\n", returnMatcherName))

	for _, field := range s.Fields {
		buf.WriteString(fmt.Sprintf("\t%s monad.Option[%s],\n",
			strings.ToLower(field.Name), field.Type))
	}
	buf.WriteString(fmt.Sprintf("\thandler func(%s) T,\n", structName))
	buf.WriteString(fmt.Sprintf(") *%s[T] {\n", returnMatcherName))

	buf.WriteString("\tif m.matched {\n\t\treturn m\n\t}\n\t\n")
	buf.WriteString("\tif m.matchFields(")
	buf.WriteString(strings.Join(fieldParams, ", "))
	buf.WriteString(") {\n")
	buf.WriteString("\t\tm.result = handler(m.value)\n")
	buf.WriteString("\t\tm.matched = true\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn m\n")
	buf.WriteString("}\n\n")

	// Generate WhenGuard for return matcher
	buf.WriteString("// WhenGuard matches against pattern with guard and returns a value\n")
	buf.WriteString(fmt.Sprintf("func (m *%s[T]) WhenGuard(\n", returnMatcherName))

	for _, field := range s.Fields {
		buf.WriteString(fmt.Sprintf("\t%s monad.Option[%s],\n",
			strings.ToLower(field.Name), field.Type))
	}
	buf.WriteString(fmt.Sprintf("\tguard func(%s) bool,\n", structName))
	buf.WriteString(fmt.Sprintf("\thandler func(%s) T,\n", structName))
	buf.WriteString(fmt.Sprintf(") *%s[T] {\n", returnMatcherName))

	buf.WriteString("\tif m.matched {\n\t\treturn m\n\t}\n\t\n")
	buf.WriteString("\tif m.matchFields(")
	buf.WriteString(strings.Join(fieldParams, ", "))
	buf.WriteString(") && guard(m.value) {\n")
	buf.WriteString("\t\tm.result = handler(m.value)\n")
	buf.WriteString("\t\tm.matched = true\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn m\n")
	buf.WriteString("}\n\n")

	// Generate Default methods for return matcher
	buf.WriteString("// Default returns default value if no pattern matched\n")
	buf.WriteString(fmt.Sprintf("func (m *%s[T]) Default(defaultValue T) T {\n", returnMatcherName))
	buf.WriteString("\tif !m.matched {\n")
	buf.WriteString("\t\treturn defaultValue\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn m.result\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// DefaultWith returns result of function if no pattern matched\n")
	buf.WriteString(fmt.Sprintf("func (m *%s[T]) DefaultWith(defaultFn func(%s) T) T {\n", returnMatcherName, structName))
	buf.WriteString("\tif !m.matched {\n")
	buf.WriteString("\t\treturn defaultFn(m.value)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn m.result\n")
	buf.WriteString("}\n\n")

	// Generate matchFields helper methods
	buf.WriteString("// matchFields checks if all fields match the pattern\n")
	buf.WriteString(fmt.Sprintf("func (m *%s) matchFields(\n", matcherName))
	for _, field := range s.Fields {
		buf.WriteString(fmt.Sprintf("\t%s monad.Option[%s],\n",
			strings.ToLower(field.Name), field.Type))
	}
	buf.WriteString(") bool {\n")

	conditions := make([]string, len(s.Fields))
	for i, field := range s.Fields {
		fieldName := strings.ToLower(field.Name)
		conditions[i] = fmt.Sprintf("m.match%sField(%s, m.value.%s)",
			exportName(field.Type), fieldName, field.Name)
	}

	buf.WriteString("\treturn " + strings.Join(conditions, " &&\n\t\t   ") + "\n")
	buf.WriteString("}\n\n")

	// Generate matchFields for return matcher
	buf.WriteString("// matchFields checks if all fields match the pattern (for return matcher)\n")
	buf.WriteString(fmt.Sprintf("func (m *%s[T]) matchFields(\n", returnMatcherName))
	for _, field := range s.Fields {
		buf.WriteString(fmt.Sprintf("\t%s monad.Option[%s],\n",
			strings.ToLower(field.Name), field.Type))
	}
	buf.WriteString(") bool {\n")

	for i, field := range s.Fields {
		fieldName := strings.ToLower(field.Name)
		conditions[i] = fmt.Sprintf("m.match%sField(%s, m.value.%s)",
			exportName(field.Type), fieldName, field.Name)
	}

	buf.WriteString("\treturn " + strings.Join(conditions, " &&\n\t\t   ") + "\n")
	buf.WriteString("}\n\n")

	// Generate field matching methods for each unique type
	typesSeen := make(map[string]bool)
	for _, field := range s.Fields {
		if typesSeen[field.Type] {
			continue
		}
		typesSeen[field.Type] = true

		typeName := exportName(field.Type)
		buf.WriteString(fmt.Sprintf("// match%sField checks if a field matches the pattern\n", typeName))
		buf.WriteString(fmt.Sprintf("func (m *%s) match%sField(pattern monad.Option[%s], value %s) bool {\n",
			matcherName, typeName, field.Type, field.Type))
		buf.WriteString("\tif pattern.IsWildcard() {\n")
		buf.WriteString("\t\treturn true // Wildcard matches anything\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\tif pattern.IsNone() {\n")
		buf.WriteString("\t\treturn false // None doesn't match actual values\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn pattern.Unwrap() == value\n")
		buf.WriteString("}\n\n")

		buf.WriteString(fmt.Sprintf("// match%sField checks if a field matches the pattern (for return matcher)\n", typeName))
		buf.WriteString(fmt.Sprintf("func (m *%s[T]) match%sField(pattern monad.Option[%s], value %s) bool {\n",
			returnMatcherName, typeName, field.Type, field.Type))
		buf.WriteString("\tif pattern.IsWildcard() {\n")
		buf.WriteString("\t\treturn true // Wildcard matches anything\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\tif pattern.IsNone() {\n")
		buf.WriteString("\t\treturn false // None doesn't match actual values\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn pattern.Unwrap() == value\n")
		buf.WriteString("}\n\n")
	}

	return nil
}

// generateReactiveCode generates reactive wrapper code for a struct
func generateReactiveCode(buf *bytes.Buffer, s parser.StructInfo) error {
	structName := s.Name
	reactiveTypeName := "Reactive" + exportName(structName)

	// Add import for monad package and sync
	buf.WriteString("import (\n")
	buf.WriteString("\t\"sync\"\n")
	buf.WriteString("\t\"sync/atomic\"\n")
	buf.WriteString("\t\"github.com/snowmerak/gofn/monad\"\n")
	buf.WriteString(")\n\n")

	// Generate reactive wrapper struct
	buf.WriteString(fmt.Sprintf("// %s provides reactive capabilities for %s\n", reactiveTypeName, structName))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", reactiveTypeName))
	buf.WriteString(fmt.Sprintf("\tvalue %s\n", structName))
	buf.WriteString(fmt.Sprintf("\tsubscribers map[int]func(old %s, new %s)\n", structName, structName))
	buf.WriteString("\tnextID int64\n")
	buf.WriteString("\tmutex sync.RWMutex\n")
	buf.WriteString("}\n\n")

	// Generate constructor
	buf.WriteString(fmt.Sprintf("// NewReactive%s creates a new reactive wrapper for %s\n", exportName(structName), structName))
	buf.WriteString(fmt.Sprintf("func NewReactive%s(initial %s) *%s {\n", exportName(structName), structName, reactiveTypeName))
	buf.WriteString(fmt.Sprintf("\treturn &%s{\n", reactiveTypeName))
	buf.WriteString("\t\tvalue: initial,\n")
	buf.WriteString(fmt.Sprintf("\t\tsubscribers: make(map[int]func(old %s, new %s)),\n", structName, structName))
	buf.WriteString("\t\tnextID: 0,\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	// Generate Get method
	buf.WriteString(fmt.Sprintf("// Get returns the current %s value (thread-safe)\n", structName))
	buf.WriteString(fmt.Sprintf("func (r *%s) Get() %s {\n", reactiveTypeName, structName))
	buf.WriteString("\tr.mutex.RLock()\n")
	buf.WriteString("\tdefer r.mutex.RUnlock()\n")
	buf.WriteString("\treturn r.value\n")
	buf.WriteString("}\n\n")

	// Generate Set method
	buf.WriteString(fmt.Sprintf("// Set updates the %s value and notifies all subscribers\n", structName))
	buf.WriteString(fmt.Sprintf("func (r *%s) Set(newValue %s) {\n", reactiveTypeName, structName))
	buf.WriteString("\tr.mutex.Lock()\n")
	buf.WriteString("\toldValue := r.value\n")
	buf.WriteString("\tr.value = newValue\n")
	buf.WriteString("\t\n")
	buf.WriteString("\t// Copy subscribers to avoid holding lock during notifications\n")
	buf.WriteString(fmt.Sprintf("\tsubscribers := make(map[int]func(old %s, new %s))\n", structName, structName))
	buf.WriteString("\tfor id, callback := range r.subscribers {\n")
	buf.WriteString("\t\tsubscribers[id] = callback\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tr.mutex.Unlock()\n")
	buf.WriteString("\t\n")
	buf.WriteString("\t// Notify subscribers outside of lock to prevent deadlocks\n")
	buf.WriteString("\tfor _, callback := range subscribers {\n")
	buf.WriteString("\t\tgo callback(oldValue, newValue)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	// Generate Update method
	buf.WriteString(fmt.Sprintf("// Update applies a function to the current %s value\n", structName))
	buf.WriteString(fmt.Sprintf("func (r *%s) Update(fn func(%s) %s) {\n", reactiveTypeName, structName, structName))
	buf.WriteString("\tr.mutex.Lock()\n")
	buf.WriteString("\toldValue := r.value\n")
	buf.WriteString("\tnewValue := fn(r.value)\n")
	buf.WriteString("\tr.value = newValue\n")
	buf.WriteString("\t\n")
	buf.WriteString("\t// Copy subscribers to avoid holding lock during notifications\n")
	buf.WriteString(fmt.Sprintf("\tsubscribers := make(map[int]func(old %s, new %s))\n", structName, structName))
	buf.WriteString("\tfor id, callback := range r.subscribers {\n")
	buf.WriteString("\t\tsubscribers[id] = callback\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tr.mutex.Unlock()\n")
	buf.WriteString("\t\n")
	buf.WriteString("\t// Notify subscribers outside of lock to prevent deadlocks\n")
	buf.WriteString("\tfor _, callback := range subscribers {\n")
	buf.WriteString("\t\tgo callback(oldValue, newValue)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	// Generate Subscribe method
	buf.WriteString("// Subscribe adds a callback for value changes\n")
	buf.WriteString("// Returns subscription ID for unsubscribing\n")
	buf.WriteString(fmt.Sprintf("func (r *%s) Subscribe(callback func(old %s, new %s)) int {\n", reactiveTypeName, structName, structName))
	buf.WriteString("\tr.mutex.Lock()\n")
	buf.WriteString("\tdefer r.mutex.Unlock()\n")
	buf.WriteString("\t\n")
	buf.WriteString("\tid := int(atomic.AddInt64(&r.nextID, 1))\n")
	buf.WriteString("\tr.subscribers[id] = callback\n")
	buf.WriteString("\treturn id\n")
	buf.WriteString("}\n\n")

	// Generate Unsubscribe method
	buf.WriteString("// Unsubscribe removes a subscription by ID\n")
	buf.WriteString(fmt.Sprintf("func (r *%s) Unsubscribe(id int) {\n", reactiveTypeName))
	buf.WriteString("\tr.mutex.Lock()\n")
	buf.WriteString("\tdefer r.mutex.Unlock()\n")
	buf.WriteString("\tdelete(r.subscribers, id)\n")
	buf.WriteString("}\n\n")

	// Generate field-specific setters that trigger reactivity
	for _, field := range s.Fields {
		// Skip private fields (fields that don't start with uppercase)
		if len(field.Name) == 0 || (field.Name[0] < 'A' || field.Name[0] > 'Z') {
			continue
		}

		setterName := "Set" + exportName(field.Name)
		buf.WriteString(fmt.Sprintf("// %s updates the %s field and notifies subscribers\n", setterName, field.Name))
		buf.WriteString(fmt.Sprintf("func (r *%s) %s(value %s) {\n", reactiveTypeName, setterName, field.Type))
		buf.WriteString(fmt.Sprintf("\tr.Update(func(current %s) %s {\n", structName, structName))
		buf.WriteString(fmt.Sprintf("\t\tcurrent.%s = value\n", field.Name))
		buf.WriteString("\t\treturn current\n")
		buf.WriteString("\t})\n")
		buf.WriteString("}\n\n")

		// Generate field getter
		getterName := "Get" + exportName(field.Name)
		buf.WriteString(fmt.Sprintf("// %s returns the current %s field value\n", getterName, field.Name))
		buf.WriteString(fmt.Sprintf("func (r *%s) %s() %s {\n", reactiveTypeName, getterName, field.Type))
		buf.WriteString(fmt.Sprintf("\treturn r.Get().%s\n", field.Name))
		buf.WriteString("}\n\n")
	}

	// Generate Map function for this specific type
	mapFuncName := fmt.Sprintf("Map%s", exportName(structName))
	buf.WriteString(fmt.Sprintf("// %s creates a reactive that transforms %s values\n", mapFuncName, structName))
	buf.WriteString(fmt.Sprintf("func %s[U any](source *%s, transform func(%s) U) *monad.Reactive[U] {\n",
		mapFuncName, reactiveTypeName, structName))
	buf.WriteString("\tresult := monad.NewReactive(transform(source.Get()))\n")
	buf.WriteString("\t\n")
	buf.WriteString(fmt.Sprintf("\tsource.Subscribe(func(old, new %s) {\n", structName))
	buf.WriteString("\t\tresult.Set(transform(new))\n")
	buf.WriteString("\t})\n")
	buf.WriteString("\t\n")
	buf.WriteString("\treturn result\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateRefCode generates reference wrapper code for a struct
func generateRefCode(buf *bytes.Buffer, s parser.StructInfo) error {
	structName := s.Name
	refTypeName := "RefOf" + exportName(structName)
	constructorName := "Reference" + exportName(structName)

	// Add import for weak package
	buf.WriteString("import \"weak\"\n\n")

	// Generate reference wrapper struct
	buf.WriteString(fmt.Sprintf("// %s provides a reference wrapper for %s\n", refTypeName, structName))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", refTypeName))
	buf.WriteString(fmt.Sprintf("\tref *%s\n", structName))
	buf.WriteString("}\n\n")

	// Generate constructor from pointer
	buf.WriteString(fmt.Sprintf("// %s creates a new reference wrapper from a pointer\n", constructorName))
	buf.WriteString(fmt.Sprintf("func %s(value *%s) *%s {\n", constructorName, structName, refTypeName))
	buf.WriteString(fmt.Sprintf("\treturn &%s{ref: value}\n", refTypeName))
	buf.WriteString("}\n\n")

	// Generate constructor from value (creates a copy)
	buf.WriteString(fmt.Sprintf("// %sFromValue creates a new reference wrapper from a value (creates a copy)\n", constructorName))
	buf.WriteString(fmt.Sprintf("func %sFromValue(value %s) *%s {\n", constructorName, structName, refTypeName))
	buf.WriteString(fmt.Sprintf("\treturn &%s{ref: &value}\n", refTypeName))
	buf.WriteString("}\n\n") // Generate Get method
	buf.WriteString(fmt.Sprintf("// Get returns the underlying pointer\n"))
	buf.WriteString(fmt.Sprintf("func (r *%s) Get() *%s {\n", refTypeName, structName))
	buf.WriteString("\treturn r.ref\n")
	buf.WriteString("}\n\n")

	// Generate Set method
	buf.WriteString(fmt.Sprintf("// Set updates the underlying pointer\n"))
	buf.WriteString(fmt.Sprintf("func (r *%s) Set(value *%s) {\n", refTypeName, structName))
	buf.WriteString("\tr.ref = value\n")
	buf.WriteString("}\n\n")

	// Generate SetValue method (creates a copy)
	buf.WriteString(fmt.Sprintf("// SetValue updates the underlying pointer with a copy of the value\n"))
	buf.WriteString(fmt.Sprintf("func (r *%s) SetValue(value %s) {\n", refTypeName, structName))
	buf.WriteString("\tr.ref = &value\n")
	buf.WriteString("}\n\n")

	// Generate IsNil method
	buf.WriteString(fmt.Sprintf("// IsNil checks if the underlying pointer is nil\n"))
	buf.WriteString(fmt.Sprintf("func (r *%s) IsNil() bool {\n", refTypeName))
	buf.WriteString("\treturn r.ref == nil\n")
	buf.WriteString("}\n\n")

	// Generate Value method (dereferenced access with nil check)
	buf.WriteString(fmt.Sprintf("// Value returns the dereferenced value, panics if nil\n"))
	buf.WriteString(fmt.Sprintf("func (r *%s) Value() %s {\n", refTypeName, structName))
	buf.WriteString("\tif r.ref == nil {\n")
	buf.WriteString(fmt.Sprintf("\t\tpanic(\"RefOf%s: attempted to access nil reference\")\n", exportName(structName)))
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn *r.ref\n")
	buf.WriteString("}\n\n")

	// Generate ValueOr method (safe dereferenced access with default)
	buf.WriteString(fmt.Sprintf("// ValueOr returns the dereferenced value or the default if nil\n"))
	buf.WriteString(fmt.Sprintf("func (r *%s) ValueOr(defaultValue %s) %s {\n", refTypeName, structName, structName))
	buf.WriteString("\tif r.ref == nil {\n")
	buf.WriteString("\t\treturn defaultValue\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn *r.ref\n")
	buf.WriteString("}\n\n")

	// Generate Weak method (creates a weak pointer)
	buf.WriteString(fmt.Sprintf("// Weak returns a weak pointer to the underlying value\n"))
	buf.WriteString(fmt.Sprintf("func (r *%s) Weak() weak.Pointer[%s] {\n", refTypeName, structName))
	buf.WriteString("\treturn weak.Make(r.ref)\n")
	buf.WriteString("}\n\n")

	return nil
}
