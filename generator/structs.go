package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/snowmerak/gofn/parser"
)

// generateStructs generates code for structs based on directives
func generateStructs(outDir string, structs []parser.StructInfo) error {
	for _, s := range structs {
		dir := strings.TrimSpace(s.Directive)
		if dir == "" {
			continue
		}

		var buf bytes.Buffer
		hdr := fmt.Sprintf("// Code generated by gofn; DO NOT EDIT.\n// gofn: %s\n\n", dir)
		buf.WriteString(hdr)
		buf.WriteString("package " + s.Package + "\n\n")

		// generation per-directive
		switch dir {
		case "pipeline":
			// generate composer using monad.Result
			buf.WriteString("import (\n\t\"github.com/snowmerak/gofn/monad\"\n)\n\n")
			compName := exportName(s.Name) + "Composer"
			n := len(s.Fields)
			if n < 2 {
				buf.WriteString("// pipeline: not enough fields to compose\n")
			} else {
				// build parameters: f1 func(T1) monad.Result[T2], ..., f{n-1}
				parts := []string{}
				for i := 0; i < n-1; i++ {
					parts = append(parts, fmt.Sprintf("f%d func(%s) monad.Result[%s]", i+1, s.Fields[i].Type, s.Fields[i+1].Type))
				}
				buf.WriteString(fmt.Sprintf("func %s(%s) func(%s) monad.Result[%s] {\n", compName, strings.Join(parts, ", "), s.Fields[0].Type, s.Fields[n-1].Type))

				// body (generated composer)
				buf.WriteString("    return func(t1 " + s.Fields[0].Type + ") monad.Result[" + s.Fields[n-1].Type + "] {\n")
				if n == 2 {
					// single-stage: just forward the call
					buf.WriteString("        return f1(t1)\n")
				} else {
					// first stage: unwrap to get value for next
					buf.WriteString("        v1, err := f1(t1).Unwrap()\n")
					buf.WriteString("        if err != nil { return monad.Err[" + s.Fields[n-1].Type + "](err) }\n")
					// middle stages: unwrap up to n-2
					for i := 2; i <= n-2; i++ {
						prev := fmt.Sprintf("v%d", i-1)
						buf.WriteString(fmt.Sprintf("        v%d, err := f%d(%s).Unwrap()\n", i, i, prev))
						buf.WriteString(fmt.Sprintf("        if err != nil { return monad.Err[%s](err) }\n", s.Fields[n-1].Type))
					}
					// final stage: call last function and return its Result
					buf.WriteString(fmt.Sprintf("        return f%d(v%d)\n", n-1, n-2))
				}
				buf.WriteString("    }\n")
				// close outer function
				buf.WriteString("}\n\n")
			}

		case "record":
			// enforce private struct name and private fields
			if !isPrivateIdent(s.Name) {
				continue
			}
			allFieldsPrivate := true
			for _, f := range s.Fields {
				if f.Name == "" || !isPrivateIdent(f.Name) {
					allFieldsPrivate = false
					break
				}
			}
			if !allFieldsPrivate {
				continue
			}

			ifaceName := exportName(s.Name)
			// interface
			buf.WriteString(fmt.Sprintf("type %s interface {\n", ifaceName))
			for _, f := range s.Fields {
				buf.WriteString(fmt.Sprintf("    %s() %s\n", exportName(f.Name), f.Type))
			}
			buf.WriteString("}\n\n")

			// constructor
			params := []string{}
			assigns := []string{}
			for i, f := range s.Fields {
				pname := fieldParamName(f.Name, i)
				params = append(params, fmt.Sprintf("%s %s", pname, f.Type))
				assigns = append(assigns, fmt.Sprintf("%s: %s", f.Name, pname))
			}
			ctorName := "New" + ifaceName
			baseCtor := fmt.Sprintf("// Generated record constructor for %s\nfunc %s(%s) %s {\n    return %s{%s}\n}\n\n",
				s.Name, ctorName, strings.Join(params, ", "), ifaceName, s.Name, strings.Join(assigns, ", "))
			buf.WriteString(baseCtor)

			// getters
			recv := strings.ToLower(string(s.Name[0]))
			for _, f := range s.Fields {
				gname := exportName(f.Name)
				getter := fmt.Sprintf("func (%s %s) %s() %s {\n    return %s.%s\n}\n\n", recv, s.Name, gname, f.Type, recv, f.Name)
				buf.WriteString(getter)
			}

		case "optional":
			optTypeName := exportName(s.Name) + "Option"
			buf.WriteString(fmt.Sprintf("type %s func(*%s)\n\n", optTypeName, s.Name))
			for i, f := range s.Fields {
				pname := fieldParamName(f.Name, i)
				buf.WriteString(fmt.Sprintf("func With%s(%s %s) %s {\n    return func(r *%s) { r.%s = %s }\n}\n\n",
					exportName(f.Name), pname, f.Type, optTypeName, s.Name, f.Name, pname))
			}
			buf.WriteString(fmt.Sprintf("func New%sWithOptions(opts ...%s) %s {\n    r := %s{}\n    for _, o := range opts { o(&r) }\n    return r\n}\n\n",
				exportName(s.Name), optTypeName, s.Name, s.Name))

		case "match":
			// Generate pattern matching code
			if err := generateMatchCode(&buf, s); err != nil {
				return fmt.Errorf("generating match code for %s: %w", s.Name, err)
			}

		default:
			// fallback constructor
			ctor := fmt.Sprintf("// Generated constructor for %s\nfunc New%s(%s) %s {\n    return %s{%s}\n}\n\n",
				s.Name, s.Name, paramsForFields(s.Fields), s.Name, s.Name, valuesForFields(s.Fields))
			buf.WriteString(ctor)
		}

		fname := fmt.Sprintf("%s_%s_gen.go", s.Name, normalizeDirective(s.Directive))
		out := filepath.Join(outDir, fname)

		// try to find source path
		srcPath := ""
		if s.Pos.Filename != "" {
			srcPath = s.Pos.Filename
		}

		formatted, err := formatSource(buf.Bytes())
		if err != nil {
			// dump raw source for inspection
			_ = os.WriteFile(out+".bad.go", buf.Bytes(), 0o644)
			fmt.Printf("gofn: format failed for %s: %v\n", fname, err)
			fmt.Printf("gofn: dumped raw source to %s.bad.go\n", out)
			return err
		}

		doGen, reason, serr := shouldGenerate(srcPath, out)
		if serr != nil {
			fmt.Printf("gofn: check should-generate for %s: %v\n", fname, serr)
		}
		if !doGen {
			fmt.Printf("gofn: skip %s - %s\n", fname, reason)
			continue
		}

		if err := os.WriteFile(out, formatted, 0o644); err != nil {
			fmt.Printf("gofn: failed to write %s: %v\n", out, err)
			return err
		}
		fmt.Printf("gofn: generated %s\n", out)
	}
	return nil
}

// generateMatchCode generates pattern matching code for a struct
func generateMatchCode(buf *bytes.Buffer, s parser.StructInfo) error {
	structName := s.Name
	matcherName := exportName(structName) + "Matcher"
	returnMatcherName := exportName(structName) + "MatcherWithReturn"
	
	// Add import for monad package
	buf.WriteString("import \"github.com/snowmerak/gofn/monad\"\n\n")
	
	// Generate matcher structs
	buf.WriteString(fmt.Sprintf("// %s provides pattern matching for %s\n", matcherName, structName))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", matcherName))
	buf.WriteString(fmt.Sprintf("\tvalue   %s\n", structName))
	buf.WriteString("\tmatched bool\n")
	buf.WriteString("}\n\n")
	
	buf.WriteString(fmt.Sprintf("// %s provides pattern matching with return values\n", returnMatcherName))
	buf.WriteString(fmt.Sprintf("type %s[T any] struct {\n", returnMatcherName))
	buf.WriteString(fmt.Sprintf("\tvalue   %s\n", structName))
	buf.WriteString("\tmatched bool\n")
	buf.WriteString("\tresult  T\n")
	buf.WriteString("}\n\n")
	
	// Generate Match method
	buf.WriteString(fmt.Sprintf("// Match starts pattern matching on %s\n", structName))
	buf.WriteString(fmt.Sprintf("func (%s %s) Match() *%s {\n", 
		strings.ToLower(string(structName[0])), structName, matcherName))
	buf.WriteString(fmt.Sprintf("\treturn &%s{value: %s, matched: false}\n", 
		matcherName, strings.ToLower(string(structName[0]))))
	buf.WriteString("}\n\n")
	
	// Generate MatchReturn function (since Go doesn't support generic methods)
	buf.WriteString(fmt.Sprintf("// Match%sReturn starts pattern matching with return value on %s\n", 
		exportName(structName), structName))
	buf.WriteString(fmt.Sprintf("func Match%sReturn[T any](%s %s) *%s[T] {\n", 
		exportName(structName), strings.ToLower(string(structName[0])), structName, returnMatcherName))
	buf.WriteString("\tvar zero T\n")
	buf.WriteString(fmt.Sprintf("\treturn &%s[T]{value: %s, matched: false, result: zero}\n", 
		returnMatcherName, strings.ToLower(string(structName[0]))))
	buf.WriteString("}\n\n")
	
	// Generate When method for basic matcher
	buf.WriteString("// When matches against the provided pattern\n")
	buf.WriteString(fmt.Sprintf("func (m *%s) When(\n", matcherName))
	
	// Generate parameters for each field
	for _, field := range s.Fields {
		buf.WriteString(fmt.Sprintf("\t%s monad.Option[%s],\n", 
			strings.ToLower(field.Name), field.Type))
	}
	buf.WriteString(fmt.Sprintf("\thandler func(%s),\n", structName))
	buf.WriteString(fmt.Sprintf(") *%s {\n", matcherName))
	
	buf.WriteString("\tif m.matched {\n\t\treturn m\n\t}\n\t\n")
	buf.WriteString("\tif m.matchFields(")
	
	// Add field parameters to matchFields call
	fieldParams := make([]string, len(s.Fields))
	for i, field := range s.Fields {
		fieldParams[i] = strings.ToLower(field.Name)
	}
	buf.WriteString(strings.Join(fieldParams, ", "))
	buf.WriteString(") {\n")
	buf.WriteString("\t\thandler(m.value)\n")
	buf.WriteString("\t\tm.matched = true\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn m\n")
	buf.WriteString("}\n\n")
	
	// Generate WhenGuard method
	buf.WriteString("// WhenGuard matches against pattern with additional condition\n")
	buf.WriteString(fmt.Sprintf("func (m *%s) WhenGuard(\n", matcherName))
	
	for _, field := range s.Fields {
		buf.WriteString(fmt.Sprintf("\t%s monad.Option[%s],\n", 
			strings.ToLower(field.Name), field.Type))
	}
	buf.WriteString(fmt.Sprintf("\tguard func(%s) bool,\n", structName))
	buf.WriteString(fmt.Sprintf("\thandler func(%s),\n", structName))
	buf.WriteString(fmt.Sprintf(") *%s {\n", matcherName))
	
	buf.WriteString("\tif m.matched {\n\t\treturn m\n\t}\n\t\n")
	buf.WriteString("\tif m.matchFields(")
	buf.WriteString(strings.Join(fieldParams, ", "))
	buf.WriteString(") && guard(m.value) {\n")
	buf.WriteString("\t\thandler(m.value)\n")
	buf.WriteString("\t\tm.matched = true\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn m\n")
	buf.WriteString("}\n\n")
	
	// Generate Default method
	buf.WriteString("// Default executes if no pattern matched\n")
	buf.WriteString(fmt.Sprintf("func (m *%s) Default(handler func(%s)) {\n", matcherName, structName))
	buf.WriteString("\tif !m.matched {\n")
	buf.WriteString("\t\thandler(m.value)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")
	
	// Generate When method for return matcher
	buf.WriteString("// When matches against pattern and returns a value\n")
	buf.WriteString(fmt.Sprintf("func (m *%s[T]) When(\n", returnMatcherName))
	
	for _, field := range s.Fields {
		buf.WriteString(fmt.Sprintf("\t%s monad.Option[%s],\n", 
			strings.ToLower(field.Name), field.Type))
	}
	buf.WriteString(fmt.Sprintf("\thandler func(%s) T,\n", structName))
	buf.WriteString(fmt.Sprintf(") *%s[T] {\n", returnMatcherName))
	
	buf.WriteString("\tif m.matched {\n\t\treturn m\n\t}\n\t\n")
	buf.WriteString("\tif m.matchFields(")
	buf.WriteString(strings.Join(fieldParams, ", "))
	buf.WriteString(") {\n")
	buf.WriteString("\t\tm.result = handler(m.value)\n")
	buf.WriteString("\t\tm.matched = true\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn m\n")
	buf.WriteString("}\n\n")
	
	// Generate WhenGuard for return matcher
	buf.WriteString("// WhenGuard matches against pattern with guard and returns a value\n")
	buf.WriteString(fmt.Sprintf("func (m *%s[T]) WhenGuard(\n", returnMatcherName))
	
	for _, field := range s.Fields {
		buf.WriteString(fmt.Sprintf("\t%s monad.Option[%s],\n", 
			strings.ToLower(field.Name), field.Type))
	}
	buf.WriteString(fmt.Sprintf("\tguard func(%s) bool,\n", structName))
	buf.WriteString(fmt.Sprintf("\thandler func(%s) T,\n", structName))
	buf.WriteString(fmt.Sprintf(") *%s[T] {\n", returnMatcherName))
	
	buf.WriteString("\tif m.matched {\n\t\treturn m\n\t}\n\t\n")
	buf.WriteString("\tif m.matchFields(")
	buf.WriteString(strings.Join(fieldParams, ", "))
	buf.WriteString(") && guard(m.value) {\n")
	buf.WriteString("\t\tm.result = handler(m.value)\n")
	buf.WriteString("\t\tm.matched = true\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn m\n")
	buf.WriteString("}\n\n")
	
	// Generate Default methods for return matcher
	buf.WriteString("// Default returns default value if no pattern matched\n")
	buf.WriteString(fmt.Sprintf("func (m *%s[T]) Default(defaultValue T) T {\n", returnMatcherName))
	buf.WriteString("\tif !m.matched {\n")
	buf.WriteString("\t\treturn defaultValue\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn m.result\n")
	buf.WriteString("}\n\n")
	
	buf.WriteString("// DefaultWith returns result of function if no pattern matched\n")
	buf.WriteString(fmt.Sprintf("func (m *%s[T]) DefaultWith(defaultFn func(%s) T) T {\n", returnMatcherName, structName))
	buf.WriteString("\tif !m.matched {\n")
	buf.WriteString("\t\treturn defaultFn(m.value)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn m.result\n")
	buf.WriteString("}\n\n")
	
	// Generate matchFields helper methods
	buf.WriteString("// matchFields checks if all fields match the pattern\n")
	buf.WriteString(fmt.Sprintf("func (m *%s) matchFields(\n", matcherName))
	for _, field := range s.Fields {
		buf.WriteString(fmt.Sprintf("\t%s monad.Option[%s],\n", 
			strings.ToLower(field.Name), field.Type))
	}
	buf.WriteString(") bool {\n")
	
	conditions := make([]string, len(s.Fields))
	for i, field := range s.Fields {
		fieldName := strings.ToLower(field.Name)
		conditions[i] = fmt.Sprintf("m.match%sField(%s, m.value.%s)", 
			exportName(field.Type), fieldName, field.Name)
	}
	
	buf.WriteString("\treturn " + strings.Join(conditions, " &&\n\t\t   ") + "\n")
	buf.WriteString("}\n\n")
	
	// Generate matchFields for return matcher
	buf.WriteString("// matchFields checks if all fields match the pattern (for return matcher)\n")
	buf.WriteString(fmt.Sprintf("func (m *%s[T]) matchFields(\n", returnMatcherName))
	for _, field := range s.Fields {
		buf.WriteString(fmt.Sprintf("\t%s monad.Option[%s],\n", 
			strings.ToLower(field.Name), field.Type))
	}
	buf.WriteString(") bool {\n")
	
	for i, field := range s.Fields {
		fieldName := strings.ToLower(field.Name)
		conditions[i] = fmt.Sprintf("m.match%sField(%s, m.value.%s)", 
			exportName(field.Type), fieldName, field.Name)
	}
	
	buf.WriteString("\treturn " + strings.Join(conditions, " &&\n\t\t   ") + "\n")
	buf.WriteString("}\n\n")
	
	// Generate field matching methods for each unique type
	typesSeen := make(map[string]bool)
	for _, field := range s.Fields {
		if typesSeen[field.Type] {
			continue
		}
		typesSeen[field.Type] = true
		
		typeName := exportName(field.Type)
		buf.WriteString(fmt.Sprintf("// match%sField checks if a field matches the pattern\n", typeName))
		buf.WriteString(fmt.Sprintf("func (m *%s) match%sField(pattern monad.Option[%s], value %s) bool {\n", 
			matcherName, typeName, field.Type, field.Type))
		buf.WriteString("\tif pattern.IsNone() {\n")
		buf.WriteString("\t\treturn true // None is wildcard\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn pattern.Unwrap() == value\n")
		buf.WriteString("}\n\n")
		
		buf.WriteString(fmt.Sprintf("// match%sField checks if a field matches the pattern (for return matcher)\n", typeName))
		buf.WriteString(fmt.Sprintf("func (m *%s[T]) match%sField(pattern monad.Option[%s], value %s) bool {\n", 
			returnMatcherName, typeName, field.Type, field.Type))
		buf.WriteString("\tif pattern.IsNone() {\n")
		buf.WriteString("\t\treturn true // None is wildcard\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn pattern.Unwrap() == value\n")
		buf.WriteString("}\n\n")
	}
	
	return nil
}